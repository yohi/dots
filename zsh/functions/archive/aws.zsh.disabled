# ===================================================================
# AWSé–¢é€£ã‚«ã‚¹ã‚¿ãƒ é–¢æ•°
# ===================================================================

# EC2 SSMæ¥ç¶š (fzfç‰ˆ)
function ec2-ssm() {
    # .aws/credentialsã‹ã‚‰profileä¸€è¦§ã‚’å–å¾—
    local profile=$(awk '/^\[/{gsub(/\[|\]/, ""); print}' ~/.aws/credentials | fzf --prompt="AWS Profile> " --height=40% --reverse)

    if [[ -z "$profile" ]]; then
        echo "profileãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚"
        return 1
    fi

    echo "Profile: $profile ã‚’ä½¿ç”¨ã—ã¾ã™"

    # é¸æŠã•ã‚ŒãŸprofileã§EC2ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä¸€è¦§ã‚’å–å¾—
    local instance_info=$(aws ec2 describe-instances \
        --profile "${profile}" \
        --filters "Name=instance-state-name,Values=running" \
        --query 'Reservations[].Instances[].[InstanceId,Tags[?Key==`Name`].Value|[0],Placement.AvailabilityZone,InstanceType]' \
        --output text | \
        awk '{
            name = ($2 == "None" || $2 == "") ? "(No Name)" : $2;
            az = $3;
            instance_type = $4;
            printf "%-19s %-30s %-12s %s\n", $1, name, az, instance_type
        }' | \
        fzf --prompt="EC2 Instance> " --height=40% --reverse --header="Instance ID         Name                           AZ           Type")

    if [[ -z "$instance_info" ]]; then
        echo "ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚"
        return 1
    fi

    local instance_id=$(echo $instance_info | awk '{print $1}')
    echo "Instance: $instance_id ã«æ¥ç¶šã—ã¾ã™"

    # SSMæ¥ç¶šã‚’å®Ÿè¡Œ
    aws ssm start-session --profile "${profile}" --target ${instance_id}
}

# ECS ã‚¿ã‚¹ã‚¯æ¥ç¶š (fzfç‰ˆ)
function ecs-exec() {
    # .aws/credentialsã‹ã‚‰profileä¸€è¦§ã‚’å–å¾—
    local profile=$(awk '/^\[/{gsub(/\[|\]/, ""); print}' ~/.aws/credentials | fzf --prompt="AWS Profile> " --height=40% --reverse)

    if [[ -z "$profile" ]]; then
        echo "profileãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚"
        return 1
    fi

    echo "Profile: $profile ã‚’ä½¿ç”¨ã—ã¾ã™"

    # ECSã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ä¸€è¦§ã‚’å–å¾—
    local cluster_arn=$(aws --profile ${profile} ecs list-clusters \
        --query 'clusterArns[]' \
        --output text | \
        sed 's|.*/||' | \
        fzf --prompt="ECS Cluster> " --height=40% --reverse)

    if [[ -z "$cluster_arn" ]]; then
        echo "ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚"
        return 1
    fi

    echo "Cluster: $cluster_arn ã‚’ä½¿ç”¨ã—ã¾ã™"

    # é¸æŠã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã§runningçŠ¶æ…‹ã®ã‚¿ã‚¹ã‚¯ä¸€è¦§ã‚’å–å¾—ï¼ˆECS Execæœ‰åŠ¹ãªã‚‚ã®ã®ã¿ï¼‰
    echo "ECS Execæœ‰åŠ¹ãªã‚¿ã‚¹ã‚¯ã‚’æ¤œç´¢ä¸­..."
    local task_info=$(aws --profile ${profile} ecs list-tasks \
        --cluster ${cluster_arn} \
        --desired-status RUNNING \
        --query 'taskArns[]' \
        --output text | \
        xargs -I {} aws --profile ${profile} ecs describe-tasks \
        --cluster ${cluster_arn} \
        --tasks {} \
        --query 'tasks[].[taskArn,taskDefinitionArn,lastStatus,enableExecuteCommand]' \
        --output text | \
        awk '{
            split($1, task_parts, "/"); task_id = task_parts[length(task_parts)];
            split($2, td_parts, "/"); td_name = td_parts[length(td_parts)];
            gsub(/:.*/, "", td_name);
            exec_enabled = ($4 == "True") ? "âœ“" : "âœ—";
            if($4 == "True") {
                printf "%-32s %-30s %-8s %s\n", task_id, td_name, $3, exec_enabled
            }
        }' | \
        fzf --prompt="ECS Task (Execæœ‰åŠ¹ã®ã¿)> " --height=40% --reverse --header="Task ID                         Task Definition            Status   Exec")

    if [[ -z "$task_info" ]]; then
        echo "ECS Execæœ‰åŠ¹ãªã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹ã€é¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚"
        echo ""
        echo "ECS Execã‚’æœ‰åŠ¹ã«ã™ã‚‹ã«ã¯ï¼š"
        echo "1. ã‚¿ã‚¹ã‚¯å®šç¾©ã§ enableExecuteCommand ã‚’ true ã«è¨­å®š"
        echo "2. ã‚¿ã‚¹ã‚¯èµ·å‹•æ™‚ã« --enable-execute-command ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æŒ‡å®š"
        echo "3. é©åˆ‡ãªIAMãƒ­ãƒ¼ãƒ«ã¨ãƒãƒªã‚·ãƒ¼ã‚’è¨­å®š"
        return 1
    fi

    local task_id=$(echo $task_info | awk '{print $1}')
    echo "Task: $task_id ã«æ¥ç¶šã—ã¾ã™"

    # ã‚³ãƒ³ãƒ†ãƒŠä¸€è¦§ã‚’å–å¾—ï¼ˆè¤‡æ•°ã‚³ãƒ³ãƒ†ãƒŠãŒã‚ã‚‹å ´åˆã«å¯¾å¿œï¼‰
    local container_name=$(aws --profile ${profile} ecs describe-tasks \
        --cluster ${cluster_arn} \
        --tasks ${task_id} \
        --query 'tasks[0].containers[].name' \
        --output text | \
        tr '\t' '\n' | \
        fzf --prompt="Container> " --height=40% --reverse)

    if [[ -z "$container_name" ]]; then
        echo "ã‚³ãƒ³ãƒ†ãƒŠãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚"
        return 1
    fi

    echo "Container: $container_name ã«æ¥ç¶šã—ã¾ã™"

    # ECS Execæ¥ç¶šã‚’å®Ÿè¡Œï¼ˆbashãŒåˆ©ç”¨å¯èƒ½ã‹ç¢ºèªã—ã¦ã‹ã‚‰shã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
    echo "æ¥ç¶šä¸­..."
    if ! aws --profile ${profile} ecs execute-command \
        --cluster ${cluster_arn} \
        --task ${task_id} \
        --container ${container_name} \
        --interactive \
        --command "/bin/bash" 2>/dev/null; then

        echo "/bin/bash ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚/bin/sh ã§å†è©¦è¡Œã—ã¾ã™..."
        if ! aws --profile ${profile} ecs execute-command \
            --cluster ${cluster_arn} \
            --task ${task_id} \
            --container ${container_name} \
            --interactive \
            --command "/bin/sh" 2>/dev/null; then

            echo ""
            echo "âŒ ECS Execæ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸã€‚"
            echo ""
            echo "è€ƒãˆã‚‰ã‚Œã‚‹åŸå› ï¼š"
            echo "â€¢ ã‚¿ã‚¹ã‚¯ã§ECS ExecãŒç„¡åŠ¹ã«ãªã£ã¦ã„ã‚‹"
            echo "â€¢ Session Manager PluginãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ãªã„"
            echo "â€¢ IAMãƒ­ãƒ¼ãƒ«ã«å¿…è¦ãªæ¨©é™ãŒãªã„"
            echo "â€¢ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¨­å®šã«å•é¡ŒãŒã‚ã‚‹"
            echo ""
            echo "è§£æ±ºæ–¹æ³•ï¼š"
            echo "1. ã‚¿ã‚¹ã‚¯ã‚’ --enable-execute-command ã§å†èµ·å‹•"
            echo "2. Session Manager Plugin ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«"
            echo "3. IAMãƒ­ãƒ¼ãƒ«ã« ssmmessages:* æ¨©é™ã‚’è¿½åŠ "
            return 1
        fi
    fi
}

# AWS CloudWatch ãƒ­ã‚°é–²è¦§ (fzfç‰ˆ) - éšå±¤æ§‹é€ ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œ
function awslogs() {
    local level="${1:-group}"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯log groupé¸æŠã¾ã§
    local help_msg="ä½¿ç”¨æ–¹æ³•: awslogs [level]
    level:
      group  - ãƒ­ã‚°ã‚°ãƒ«ãƒ¼ãƒ—å˜ä½ã§é¸æŠ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)
      stream - ãƒ­ã‚°ã‚¹ãƒˆãƒªãƒ¼ãƒ å˜ä½ã§é¸æŠï¼ˆéšå±¤æ§‹é€ å¯¾å¿œï¼‰
      help   - ã“ã®ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º"

    # ãƒ˜ãƒ«ãƒ—è¡¨ç¤º
    if [[ "$level" == "help" || "$level" == "--help" || "$level" == "-h" ]]; then
        echo "$help_msg"
        return 0
    fi

    # .aws/credentialsã‹ã‚‰profileä¸€è¦§ã‚’å–å¾—
    local profile=$(awk '/^\[/{gsub(/\[|\]/, ""); print}' ~/.aws/credentials | fzf --prompt="AWS Profile> " --height=40% --reverse)

    if [[ -z "$profile" ]]; then
        echo "profileãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚"
        return 1
    fi

    echo "Profile: $profile ã‚’ä½¿ç”¨ã—ã¾ã™"

    # é¸æŠã•ã‚ŒãŸprofileã§ãƒ­ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ä¸€è¦§ã‚’å–å¾—
    local log_group_name=$(aws --profile ${profile} logs describe-log-groups \
        --query 'logGroups[].[logGroupName,retentionInDays,storedBytes]' \
        --output text | \
        awk '{
            retention = ($2 == "None" || $2 == "") ? "ç„¡æœŸé™" : $2"æ—¥";
            size_mb = $3 > 0 ? sprintf("%.1fMB", $3/1024/1024) : "0MB";
            printf "%-50s [ä¿æŒ:%s, ã‚µã‚¤ã‚º:%s]\n", $1, retention, size_mb
        }' | \
        fzf --prompt="Log Group> " --height=40% --reverse --header="Log Group Name                                   [Retention, Size]")

    if [[ -z "$log_group_name" ]]; then
        echo "ãƒ­ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚"
        return 1
    fi

    # ãƒ­ã‚°ã‚°ãƒ«ãƒ¼ãƒ—åã ã‘ã‚’æŠ½å‡ºï¼ˆãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæƒ…å ±ã‚’é™¤å»ï¼‰
    local clean_log_group_name=$(echo $log_group_name | awk '{print $1}')
    echo "Log Group: $clean_log_group_name ã‚’é¸æŠã—ã¾ã—ãŸ"

    local log_stream_name=""
    local filter_pattern=""

    # ãƒ­ã‚°ã‚¹ãƒˆãƒªãƒ¼ãƒ å˜ä½ã§ã®é¸æŠãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆï¼ˆéšå±¤æ§‹é€ å¯¾å¿œï¼‰
    if [[ "$level" == "stream" ]]; then
        echo "ãƒ­ã‚°ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å–å¾—ä¸­..."

        # å…¨ãƒ­ã‚°ã‚¹ãƒˆãƒªãƒ¼ãƒ ä¸€è¦§ã‚’å–å¾—
        local all_streams=$(aws --profile ${profile} logs describe-log-streams \
            --log-group-name "${clean_log_group_name}" \
            --order-by LastEventTime \
            --descending \
            --max-items 200 \
            --query 'logStreams[].[logStreamName,lastEventTime,storedBytes]' \
            --output text)

        if [[ -z "$all_streams" ]]; then
            echo "ãƒ­ã‚°ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚"
            return 1
        fi

        # éšå±¤æ§‹é€ ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°
        function navigate_stream_hierarchy() {
            local current_path="${1:-}"
            local depth="${2:-0}"

            # ç¾åœ¨ã®ãƒ‘ã‚¹ã«ãƒãƒƒãƒã™ã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æŠ½å‡ºã—ã€æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã®é¸æŠè‚¢ã‚’ä½œæˆ
            local stream_map_file=$(mktemp)

            # ç¾åœ¨ã®ãƒ‘ã‚¹é…ä¸‹ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ä¸€è¦§ã‚’æ§‹ç¯‰
            while IFS=$'\t' read -r stream_name last_event stored_bytes; do
                if [[ -z "$current_path" || "$stream_name" == "$current_path"* ]]; then
                    # ç¾åœ¨ã®ãƒ‘ã‚¹ä»¥é™ã®éƒ¨åˆ†ã‚’å–å¾—
                    local remaining_path="${stream_name#$current_path}"
                    [[ "$remaining_path" == "$stream_name" && -n "$current_path" ]] && continue

                    # æ¬¡ã®ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¾ã§ã®éƒ¨åˆ†ã‚’å–å¾—
                    if [[ "$remaining_path" == */* ]]; then
                        local next_segment="${remaining_path%%/*}"
                        if [[ -n "$next_segment" ]]; then
                            local display_name="$current_path$next_segment/"
                            echo "$display_name" >> "$stream_map_file.dirs"
                        fi
                    else
                        # å®Œå…¨ãªã‚¹ãƒˆãƒªãƒ¼ãƒ åï¼ˆçµ‚ç«¯ï¼‰
                        if [[ -n "$remaining_path" ]]; then
                            local time_str="æœªè¨˜éŒ²"
                            if [[ -n "$last_event" && "$last_event" != "None" ]]; then
                                time_str=$(date -d "@$((last_event/1000))" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "æœªè¨˜éŒ²")
                            fi
                            local size_kb="0KB"
                            if [[ -n "$stored_bytes" && "$stored_bytes" -gt 0 ]]; then
                                size_kb=$(printf "%.1fKB" $((stored_bytes/1024)))
                            fi
                            printf "%-80s [æœ€çµ‚:%s, ã‚µã‚¤ã‚º:%s]\n" "$stream_name" "$time_str" "$size_kb" >> "$stream_map_file.streams"
                        fi
                    fi
                fi
            done <<< "$all_streams"

            # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ¬ãƒ™ãƒ«ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ä½œæˆï¼ˆé‡è¤‡é™¤å»ãƒ»ã‚½ãƒ¼ãƒˆï¼‰
            local dir_options=""
            if [[ -f "$stream_map_file.dirs" ]]; then
                dir_options=$(sort -u "$stream_map_file.dirs")
            fi

            # ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ
            local stream_options=""
            if [[ -f "$stream_map_file.streams" ]]; then
                stream_options=$(cat "$stream_map_file.streams")
            fi

            # æˆ»ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ï¼ˆãƒ«ãƒ¼ãƒˆä»¥å¤–ï¼‰
            local back_option=""
            if [[ -n "$current_path" ]]; then
                back_option="ğŸ”™ æˆ»ã‚‹ (ä¸Šä½éšå±¤ã¸)"
            fi

            # ç¾åœ¨ã®éšå±¤ä»¥ä¸‹ã®ã™ã¹ã¦ã‚’é¸æŠã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³
            local select_all_option=""
            if [[ -n "$stream_options" || -n "$dir_options" ]]; then
                local path_display="${current_path:-ã™ã¹ã¦}"
                select_all_option="ğŸ“ ã“ã®éšå±¤ä»¥ä¸‹ã®ã™ã¹ã¦ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¡¨ç¤º ($path_display*)"
            fi

            # é¸æŠè‚¢ã‚’çµ±åˆ
            local all_options=""
            [[ -n "$back_option" ]] && all_options="$back_option"
            [[ -n "$select_all_option" ]] && {
                [[ -n "$all_options" ]] && all_options="$all_options"$'\n'
                all_options="$all_options$select_all_option"
            }
            if [[ -n "$dir_options" ]]; then
                [[ -n "$all_options" ]] && all_options="$all_options"$'\n'
                all_options="$all_options$dir_options"
            fi
            if [[ -n "$stream_options" ]]; then
                [[ -n "$all_options" ]] && all_options="$all_options"$'\n'
                all_options="$all_options$stream_options"
            fi

            # ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            rm -f "$stream_map_file" "$stream_map_file.dirs" "$stream_map_file.streams"

            if [[ -z "$all_options" ]]; then
                echo "ã“ã®ãƒ‘ã‚¹ã«ã¯ãƒ­ã‚°ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"
                return 1
            fi

            # fzfã§é¸æŠ
            local path_display="${current_path:-/}"
            local selection=$(echo "$all_options" | fzf \
                --prompt="Path: $path_display > " \
                --height=60% --reverse \
                --header="éšå±¤ã‚’é¸æŠã—ã¦ãã ã•ã„ (ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: /, ğŸ“: éšå±¤ä¸€æ‹¬, ã‚¹ãƒˆãƒªãƒ¼ãƒ : æ™‚é–“æƒ…å ±ä»˜ã)")

            if [[ -z "$selection" ]]; then
                echo "é¸æŠãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚"
                return 1
            fi

            # é¸æŠçµæœã®å‡¦ç†
            if [[ "$selection" == "ğŸ”™ æˆ»ã‚‹ (ä¸Šä½éšå±¤ã¸)" ]]; then
                # ä¸Šä½éšå±¤ã«æˆ»ã‚‹
                local parent_path="${current_path%/}"
                parent_path="${parent_path%/*}"
                [[ -n "$parent_path" ]] && parent_path="$parent_path/"
                navigate_stream_hierarchy "$parent_path" $((depth-1))
            elif [[ "$selection" == "ğŸ“ ã“ã®éšå±¤ä»¥ä¸‹ã®ã™ã¹ã¦ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¡¨ç¤º"* ]]; then
                # ç¾åœ¨ã®éšå±¤ä»¥ä¸‹ã®ã™ã¹ã¦ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’é¸æŠ
                echo "éšå±¤ '$current_path' ä»¥ä¸‹ã®ã™ã¹ã¦ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’é¸æŠã—ã¾ã—ãŸ"
                log_stream_name="$current_path*"
                return 0
            elif [[ "$selection" == */ ]]; then
                # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒé¸æŠã•ã‚ŒãŸå ´åˆã€ã•ã‚‰ã«æ·±ã
                navigate_stream_hierarchy "$selection" $((depth+1))
            else
                # ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒé¸æŠã•ã‚ŒãŸå ´åˆ
                log_stream_name=$(echo "$selection" | awk '{print $1}')
                echo "Log Stream: $log_stream_name ã‚’é¸æŠã—ã¾ã—ãŸ"
                return 0
            fi
        }

        # éšå±¤ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹
        navigate_stream_hierarchy "" 0

        if [[ -z "$log_stream_name" ]]; then
            echo "ãƒ­ã‚°ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚"
            return 1
        fi

        # ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã®é¸æŠ
        echo "ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼š"
        local filter_option=$(echo -e "ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãªã—\nERRORãƒ¬ãƒ™ãƒ«ã®ã¿\nWARNãƒ¬ãƒ™ãƒ«ä»¥ä¸Š\nã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼\nJSONå½¢å¼ãƒ­ã‚°ã®ç‰¹å®šãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰" | \
            fzf --prompt="Filter> " --height=40% --reverse)

        case "$filter_option" in
            "ERRORãƒ¬ãƒ™ãƒ«ã®ã¿")
                filter_pattern="ERROR"
                ;;
            "WARNãƒ¬ãƒ™ãƒ«ä»¥ä¸Š")
                filter_pattern="?WARN ?ERROR"
                ;;
            "ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼")
                echo "ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹: [timestamp, request_id, ERROR]ï¼‰:"
                read custom_filter
                if [[ -n "$custom_filter" ]]; then
                    filter_pattern="$custom_filter"
                fi
                ;;
            "JSONå½¢å¼ãƒ­ã‚°ã®ç‰¹å®šãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰")
                echo "JSONãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ï¼ˆä¾‹: $.level = \"ERROR\"ï¼‰:"
                read json_filter
                if [[ -n "$json_filter" ]]; then
                    filter_pattern="$json_filter"
                fi
                ;;
        esac
    fi

    # è¡¨ç¤ºæ–¹æ³•ã®é¸æŠ
    echo "è¡¨ç¤ºæ–¹æ³•ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼š"
    local action=$(echo -e "ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤º (--follow)\néå»1æ™‚é–“ã®ãƒ­ã‚°\néå»24æ™‚é–“ã®ãƒ­ã‚°\næŒ‡å®šæ™‚é–“ç¯„å›²ã®ãƒ­ã‚°" | \
        fzf --prompt="è¡¨ç¤ºæ–¹æ³•> " --height=40% --reverse)

    # AWS CLIã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œ
    if [[ "$level" == "stream" && -n "$log_stream_name" ]]; then
        # ãƒ­ã‚°ã‚¹ãƒˆãƒªãƒ¼ãƒ æŒ‡å®šã®å ´åˆã¯filter-log-eventsã‚’ä½¿ç”¨
        local aws_cmd=""

        if [[ "$log_stream_name" == *"*" ]]; then
            # éšå±¤é¸æŠï¼ˆãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ï¼‰ã®å ´åˆã€ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’ä½¿ç”¨
            local prefix="${log_stream_name%*}"

            echo "éšå±¤ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹: $prefix ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ã¾ã™"

            # log-stream-name-prefixã‚’ä½¿ç”¨ã—ã¦ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒãƒƒãƒãƒ³ã‚°
            aws_cmd="aws --profile ${profile} logs filter-log-events --log-group-name \"${clean_log_group_name}\" --log-stream-name-prefix \"${prefix}\""
        else
            # å˜ä¸€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å ´åˆ
            aws_cmd="aws --profile ${profile} logs filter-log-events --log-group-name \"${clean_log_group_name}\" --log-stream-names \"${log_stream_name}\""
        fi

        if [[ -n "$filter_pattern" ]]; then
            aws_cmd="${aws_cmd} --filter-pattern \"${filter_pattern}\""
        fi

        case "$action" in
            "ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤º (--follow)")
                if [[ "$log_stream_name" == *"*" ]]; then
                    echo "è¤‡æ•°ã‚¹ãƒˆãƒªãƒ¼ãƒ æŒ‡å®šæ™‚ã¯aws logs tailã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤ºã‚’è©¦è¡Œã—ã¾ã™..."
                    # ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒãƒƒãƒãƒ³ã‚°ã§aws logs tailã‚’ä½¿ç”¨
                    local prefix="${log_stream_name%*}"
                    aws --profile ${profile} logs tail ${clean_log_group_name} --follow --log-stream-name-prefix "${prefix}"
                    return 0
                else
                    echo "å˜ä¸€ã‚¹ãƒˆãƒªãƒ¼ãƒ æŒ‡å®šæ™‚ã¯ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤ºãŒã§ãã¾ã›ã‚“ã€‚æœ€æ–°ã®ãƒ­ã‚°ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚"
                    aws_cmd="${aws_cmd} --start-time $(date -d '1 hour ago' +%s)000"
                fi
                ;;
            "éå»1æ™‚é–“ã®ãƒ­ã‚°")
                aws_cmd="${aws_cmd} --start-time $(date -d '1 hour ago' +%s)000"
                ;;
            "éå»24æ™‚é–“ã®ãƒ­ã‚°")
                aws_cmd="${aws_cmd} --start-time $(date -d '1 day ago' +%s)000"
                ;;
            "æŒ‡å®šæ™‚é–“ç¯„å›²ã®ãƒ­ã‚°")
                echo "é–‹å§‹æ™‚é–“ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (ä¾‹: 2024-01-01T10:00:00):"
                read start_time
                echo "çµ‚äº†æ™‚é–“ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (ä¾‹: 2024-01-01T12:00:00):"
                read end_time
                if [[ -n "$start_time" && -n "$end_time" ]]; then
                    start_ms=$(date -d "${start_time}" +%s)000
                    end_ms=$(date -d "${end_time}" +%s)000
                    aws_cmd="${aws_cmd} --start-time ${start_ms} --end-time ${end_ms}"
                else
                    echo "æ™‚é–“ç¯„å›²ãŒæ­£ã—ãæŒ‡å®šã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚"
                    return 1
                fi
                ;;
        esac

        # ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼çµæœã‚’æ•´å½¢ã—ã¦è¡¨ç¤º
        echo "å®Ÿè¡Œä¸­: $aws_cmd"
        eval "$aws_cmd" | jq -r '.events[] | "\(.timestamp/1000 | strftime("%Y-%m-%d %H:%M:%S")) [\\(.logStreamName)] \\(.message)"' 2>/dev/null || \
        eval "$aws_cmd" --query 'events[].[timestamp,logStreamName,message]' --output text | \
        awk '{
            if($1 > 0) {
                timestamp = strftime("%Y-%m-%d %H:%M:%S", $1/1000);
                stream = $2;
                $1 = $2 = "";
                message = substr($0, 3);
                printf "%s [%s] %s\n", timestamp, stream, message;
            }
        }'

    else
        # å¾“æ¥ã®tailã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ï¼ˆãƒ­ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ãƒ¬ãƒ™ãƒ«ï¼‰
        case "$action" in
            "ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤º (--follow)")
                echo "ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ãƒ­ã‚°ã‚’è¡¨ç¤ºã—ã¾ã™ (Ctrl+Cã§çµ‚äº†)"
                aws --profile ${profile} logs tail ${clean_log_group_name} --follow
                ;;
            "éå»1æ™‚é–“ã®ãƒ­ã‚°")
                echo "éå»1æ™‚é–“ã®ãƒ­ã‚°ã‚’è¡¨ç¤ºã—ã¾ã™"
                aws --profile ${profile} logs tail ${clean_log_group_name} --since 1h
                ;;
            "éå»24æ™‚é–“ã®ãƒ­ã‚°")
                echo "éå»24æ™‚é–“ã®ãƒ­ã‚°ã‚’è¡¨ç¤ºã—ã¾ã™"
                aws --profile ${profile} logs tail ${clean_log_group_name} --since 24h
                ;;
            "æŒ‡å®šæ™‚é–“ç¯„å›²ã®ãƒ­ã‚°")
                echo "é–‹å§‹æ™‚é–“ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (ä¾‹: 2024-01-01T10:00:00):"
                read start_time
                echo "çµ‚äº†æ™‚é–“ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (ä¾‹: 2024-01-01T12:00:00):"
                read end_time
                if [[ -n "$start_time" && -n "$end_time" ]]; then
                    echo "æŒ‡å®šã•ã‚ŒãŸæ™‚é–“ç¯„å›²ã®ãƒ­ã‚°ã‚’è¡¨ç¤ºã—ã¾ã™"
                    aws --profile ${profile} logs tail ${clean_log_group_name} --since "${start_time}" --until "${end_time}"
                else
                    echo "æ™‚é–“ç¯„å›²ãŒæ­£ã—ãæŒ‡å®šã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚"
                    return 1
                fi
                ;;
            *)
                echo "æ“ä½œãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚"
                return 1
                ;;
        esac
    fi
}

# RDS IAMèªè¨¼æ¥ç¶š (fzfç‰ˆ)
function rds-iam() {
    local help_msg="ä½¿ç”¨æ–¹æ³•: rds-iam [database_type]
    database_type:
      mysql     - MySQL/MariaDBæ¥ç¶š (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)
      postgres  - PostgreSQLæ¥ç¶š
      aurora    - Aurora MySQL/PostgreSQLæ¥ç¶š
      help      - ã“ã®ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º

    å¿…è¦ãªå‰ææ¡ä»¶:
    â€¢ AWS CLIè¨­å®šæ¸ˆã¿
    â€¢ RDS IAMèªè¨¼ãŒæœ‰åŠ¹åŒ–ã•ã‚Œã¦ã„ã‚‹
    â€¢ é©åˆ‡ãªIAMæ¨©é™ (rds-db:connect)
    â€¢ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ (mysql, psqlç­‰) ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿"

    # ãƒ˜ãƒ«ãƒ—è¡¨ç¤º
    if [[ "$1" == "help" || "$1" == "--help" || "$1" == "-h" ]]; then
        echo "$help_msg"
        return 0
    fi

    local db_type="${1:-mysql}"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯MySQL

    # .aws/credentialsã‹ã‚‰profileä¸€è¦§ã‚’å–å¾—
    local profile=$(awk '/^\[/{gsub(/\[|\]/, ""); print}' ~/.aws/credentials | fzf --prompt="AWS Profile> " --height=40% --reverse)

    if [[ -z "$profile" ]]; then
        echo "profileãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚"
        return 1
    fi

    echo "Profile: $profile ã‚’ä½¿ç”¨ã—ã¾ã™"

    # é¸æŠã•ã‚ŒãŸprofileã§RDSã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä¸€è¦§ã‚’å–å¾—
    echo "RDSã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—ä¸­..."
    local rds_info=$(aws rds describe-db-instances \
        --profile "${profile}" \
        --query 'DBInstances[].[DBInstanceIdentifier,Engine,DBInstanceStatus,Endpoint.Address,Endpoint.Port,MasterUsername]' \
        --output text | \
        awk '{
            status_icon = ($3 == "available") ? "ğŸŸ¢" : "ğŸ”´";
            printf "%-30s %-15s %s %-15s %-5s %s\n", $1, $2, status_icon, $4, $5, $6
        }' | \
        fzf --prompt="RDS Instance> " --height=40% --reverse --header="Instance ID                    Engine          Status   Endpoint           Port   Username")

    if [[ -z "$rds_info" ]]; then
        echo "RDSã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚"
        return 1
    fi

    local instance_id=$(echo $rds_info | awk '{print $1}')
    local engine=$(echo $rds_info | awk '{print $2}')
    local endpoint=$(echo $rds_info | awk '{print $4}')
    local port=$(echo $rds_info | awk '{print $5}')
    local username=$(echo $rds_info | awk '{print $6}')

    echo "Instance: $instance_id (${engine}) ã‚’é¸æŠã—ã¾ã—ãŸ"
    echo "Endpoint: $endpoint:$port"
    echo "Username: $username"

    # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åã®å…¥åŠ›
    echo "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (ç©ºã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆDBã«æ¥ç¶š):"
    read database_name

    # IAMèªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã®ç”Ÿæˆ
    echo "IAMèªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆä¸­..."
    local token=$(aws rds generate-db-auth-token \
        --profile "${profile}" \
        --hostname "${endpoint}" \
        --port "${port}" \
        --username "${username}" \
        --region $(aws configure get region --profile "${profile}") 2>/dev/null)

    if [[ -z "$token" ]]; then
        echo "âŒ IAMèªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚"
        echo ""
        echo "è€ƒãˆã‚‰ã‚Œã‚‹åŸå› ï¼š"
        echo "â€¢ IAMèªè¨¼ãŒæœ‰åŠ¹åŒ–ã•ã‚Œã¦ã„ãªã„"
        echo "â€¢ é©åˆ‡ãªIAMæ¨©é™ãŒãªã„ (rds-db:connect)"
        echo "â€¢ AWS CLIè¨­å®šã«å•é¡ŒãŒã‚ã‚‹"
        echo "â€¢ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã®å•é¡Œ"
        return 1
    fi

    echo "âœ… IAMèªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆã—ã¾ã—ãŸ"

    # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸæ¥ç¶šã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œ
    case "$engine" in
        "mysql"|"mariadb")
            echo "MySQL/MariaDBã«æ¥ç¶šã—ã¾ã™..."
            if command -v mysql >/dev/null 2>&1; then
                local mysql_cmd="mysql -h ${endpoint} -P ${port} -u ${username} -p${token}"
                if [[ -n "$database_name" ]]; then
                    mysql_cmd="${mysql_cmd} ${database_name}"
                fi
                echo "å®Ÿè¡Œä¸­: $mysql_cmd"
                eval "$mysql_cmd"
            else
                echo "âŒ mysql ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
                echo "ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ–¹æ³•:"
                echo "  Ubuntu/Debian: sudo apt-get install mysql-client"
                echo "  macOS: brew install mysql-client"
                return 1
            fi
            ;;
        "postgres")
            echo "PostgreSQLã«æ¥ç¶šã—ã¾ã™..."
            if command -v psql >/dev/null 2>&1; then
                local psql_cmd="psql -h ${endpoint} -p ${port} -U ${username} -d ${database_name:-postgres}"
                echo "å®Ÿè¡Œä¸­: $psql_cmd"
                echo "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã€ä»¥ä¸‹ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:"
                echo "${token}"
                echo ""
                eval "$psql_cmd"
            else
                echo "âŒ psql ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
                echo "ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ–¹æ³•:"
                echo "  Ubuntu/Debian: sudo apt-get install postgresql-client"
                echo "  macOS: brew install postgresql"
                return 1
            fi
            ;;
        "aurora-mysql")
            echo "Aurora MySQLã«æ¥ç¶šã—ã¾ã™..."
            if command -v mysql >/dev/null 2>&1; then
                local mysql_cmd="mysql -h ${endpoint} -P ${port} -u ${username} -p${token}"
                if [[ -n "$database_name" ]]; then
                    mysql_cmd="${mysql_cmd} ${database_name}"
                fi
                echo "å®Ÿè¡Œä¸­: $mysql_cmd"
                eval "$mysql_cmd"
            else
                echo "âŒ mysql ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
                echo "ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ–¹æ³•:"
                echo "  Ubuntu/Debian: sudo apt-get install mysql-client"
                echo "  macOS: brew install mysql-client"
                return 1
            fi
            ;;
        "aurora-postgresql")
            echo "Aurora PostgreSQLã«æ¥ç¶šã—ã¾ã™..."
            if command -v psql >/dev/null 2>&1; then
                local psql_cmd="psql -h ${endpoint} -p ${port} -U ${username} -d ${database_name:-postgres}"
                echo "å®Ÿè¡Œä¸­: $psql_cmd"
                echo "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã€ä»¥ä¸‹ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:"
                echo "${token}"
                echo ""
                eval "$psql_cmd"
            else
                echo "âŒ psql ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
                echo "ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ–¹æ³•:"
                echo "  Ubuntu/Debian: sudo apt-get install postgresql-client"
                echo "  macOS: brew install postgresql"
                return 1
            fi
            ;;
        *)
            echo "âŒ ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¨ãƒ³ã‚¸ãƒ³ã§ã™: $engine"
            echo "ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‚¨ãƒ³ã‚¸ãƒ³: mysql, mariadb, postgres, aurora-mysql, aurora-postgresql"
            return 1
            ;;
    esac
}
